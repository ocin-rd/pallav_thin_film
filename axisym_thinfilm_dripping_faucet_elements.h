//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//    Version 1.0; svn revision $LastChangedRevision: 1307 $
//LIC//
//LIC// $LastChangedDate: 2018-01-18 11:30:14 +0000 (Thu, 18 Jan 2018) $
//LIC// 
//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header file for thin film DrippingFaucet elements
#ifndef OOMPH_AXISYM_THINFILM_DRIPPING_FAUCET_ELEMENTS_HEADER
#define OOMPH_AXISYM_THINFILM_DRIPPING_FAUCET_ELEMENTS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include<sstream>

//OOMPH-LIB headers
#include "../../../src/generic/nodes.h"
#include "../../../src/generic/Qelements.h"
#include "../../../src/generic/oomph_utilities.h"



namespace oomph
{

//=============================================================
/// A class for all isoparametric elements that solve the 
/// axisymmetric thin film DrippingFaucet equations.
/// \f[ 
/// insert equation here
/// \f] 
/// This contains the generic maths. Shape functions, geometric
/// mapping etc. must get implemented in derived class.
//=============================================================
class AxisymmetricThinFilmDrippingFaucetEquations : public virtual FiniteElement
{
private:

 /// Static default value for the physical constants (all initialised to zero)
 static double Default_Physical_Constant_Value;

 /// Static default value for the physical constant rates (all initialised to one)
 static double Default_Physical_Ratio_Value;

public:

 /// \short Function pointer to body force function fct(t,f(t))
 typedef void (*AxisymmetricThinFilmDrippingFaucetBodyForceFctPt)(const double& t, double& f);

 /// Ohnesorg number
 const double &oh() const {return *Oh_pt;}

  /// Pointer to Ohnesorg number
 double* &oh_pt() {return Oh_pt;}

 /// Constructor (must initialise the Body_force_fct_pt to null)
 AxisymmetricThinFilmDrippingFaucetEquations() : Body_force_fct_pt(0)
  {
   Oh_pt = &Default_Physical_Constant_Value;
  }
 
 /// Broken copy constructor
 AxisymmetricThinFilmDrippingFaucetEquations(const AxisymmetricThinFilmDrippingFaucetEquations& dummy) 
  { 
   BrokenCopy::broken_copy("AxisymmetricThinFilmDrippingFaucetEquations");
  } 
 
 /// Broken assignment operator
 void operator=(const AxisymmetricThinFilmDrippingFaucetEquations&) 
  {
   BrokenCopy::broken_assign("AxisymmetricThinFilmDrippingFaucetEquations");
  }

 /// \short Return the index at which the unknown value
 /// is stored. The default value, 0, is appropriate for single-physics
 /// problems, when there is only one variable, the value that satisfies
 /// the poisson equation. 
 /// In derived multi-physics elements, this function should be overloaded
 /// to reflect the chosen storage scheme. Note that these equations require
 /// that the unknown is always stored at the same index at each node.
 virtual inline unsigned h_index_axisym_thinfilm_dripping_faucet() const {return 0;}

 // Velocity
 virtual inline unsigned u_index_axisym_thinfilm_dripping_faucet() const {return 1;}

 // Helper variable
 virtual inline unsigned omega_index_axisym_thinfilm_dripping_faucet() const {return 2;}

 /// \short Number of scalars/fields output by this element. Reimplements
 /// broken virtual function in base class.
 unsigned nscalar_paraview() const
  {
   return 3;
  }

 /// \short Write values of the i-th scalar field at the plot points. Needs 
 /// to be implemented for each new specific element type.
 void scalar_value_paraview(std::ofstream& file_out,
                            const unsigned& i,
                            const unsigned& nplot) const
  {
#ifdef PARANOID
   if (i>2)
    {
     std::stringstream error_stream;
     error_stream 
      << "AxisymmetricThinFilmDrippingFaucet elements only store three single fields so i must"
      << " be 0 to 2 rather than " << i << std::endl;
     throw OomphLibError(
      error_stream.str(),
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
    }
#endif

   unsigned local_loop=this->nplot_points_paraview(nplot);
   for(unsigned j=0;j<local_loop;j++)
    {
     // Get the local coordinate of the required plot point
     Vector<double> s(1); 
     this->get_s_plot(j,nplot,s);
     
     file_out << this->interpolated_h_axisym_thinfilm_dripping_faucet(s) 
	      << this->interpolated_u_axisym_thinfilm_dripping_faucet(s)
	      << this->interpolated_omega_axisym_thinfilm_dripping_faucet(s)
	      << std::endl;
    }
  }

 /// \short Name of the i-th scalar field. Default implementation
 /// returns V1 for the first one, V2 for the second etc. Can (should!) be
 /// overloaded with more meaningful names in specific elements.
 std::string scalar_name_paraview(const unsigned& i) const
  {

#ifdef PARANOID
   if (i>2)
    {
     std::stringstream error_stream;
     error_stream 
      << "AxisymmetricThinFilmDrippingFaucet elements only store three single fields so i must"
      << " be 0 to 2 rather than " << i << std::endl;
     throw OomphLibError(
      error_stream.str(),
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
    }
#endif

     return "AxisymmetricThinFilmDrippingFaucet solution";
  }

 /// Output with default number of plot points
 void output(std::ostream &outfile) 
  {
   const unsigned n_plot=5;
   output(outfile,n_plot);
  }

 /// \short Output FE representation of soln: x,y,u or x,y,z,u at 
 /// n_plot^DIM plot points
 void output(std::ostream &outfile, const unsigned &n_plot);

 /// C_style output with default number of plot points
 void output(FILE* file_pt)
  {
   const unsigned n_plot=5;
   output(file_pt,n_plot);
  }

 /// \short C-style output FE representation of soln: x,y,u or x,y,z,u at 
 /// n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot);

   /// \short Compute norm of solution: square of the L2 norm
   void compute_norm(double& norm);

 /// Access function: Pointer to body force function
 AxisymmetricThinFilmDrippingFaucetBodyForceFctPt& body_force_fct_pt() {return Body_force_fct_pt;}

 /// Access function: Pointer to body force function. Const version
 AxisymmetricThinFilmDrippingFaucetBodyForceFctPt body_force_fct_pt() const {return Body_force_fct_pt;}

 /// Get source term at (Eulerian) position x. This function is
 /// virtual to allow overloading in multi-physics problems where
 /// the strength of the source function might be determined by
 /// another system of equations.
 inline virtual void get_body_force_axisym_thinfilm_dripping_faucet(const unsigned& ipt,
							     const double& t,
							     double& force) const
  {
   //If no body force function has been set, return zero
   if(Body_force_fct_pt==0) {force = 0.0;}
   else
    {
     // Get body force
     (*Body_force_fct_pt)(t,force);
    }
  }


 /// Get flux: flux[0] = dh/dz, flux[1] = du/dz
 void get_flux(const Vector<double>& s, Vector<double>& flux) const
  {
   //Find out how many nodes there are in the element
   const unsigned n_node = nnode();

   //Get the index at which the unknown is stored
   const unsigned h_nodal_index = h_index_axisym_thinfilm_dripping_faucet();
   const unsigned u_nodal_index = u_index_axisym_thinfilm_dripping_faucet();

   //Set up memory for the shape function
   Shape psi(n_node);
   DShape dpsidx(n_node,2);
 
   //Call the derivatives of the shape and test functions
   dshape_eulerian(s,psi,dpsidx);
     
   //Initialise to zero
   flux[0] = 0.0;
   flux[1] = 0.0;
   
   // Loop over nodes
   for(unsigned l=0;l<n_node;l++) 
    {                               
     flux[0] += this->nodal_value(l,h_nodal_index)*dpsidx(l,0);                        
     flux[1] += this->nodal_value(l,u_nodal_index)*dpsidx(l,0);
    }
  }


 /// Add the element's contribution to its residual vector (wrapper)
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0
   //using a dummy matrix argument
   fill_in_generic_residual_contribution_axisym_thinfilm_dripping_faucet(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }

 
 /// Add the element's contribution to its residual vector and 
 /// element Jacobian matrix (wrapper)
 /// obacht jacobian not quite right, fall back to FD
 /* void fill_in_contribution_to_jacobian(Vector<double> &residuals, */
 /*                                   DenseMatrix<double> &jacobian) */
 /*  { */
 /*   //Call the generic routine with the flag set to 1 */
 /*   fill_in_generic_residual_contribution_axisym_thinfilm_dripping_faucet(residuals,jacobian,1); */
 /*  } */ 


 /// \short Return FE representation of function value h_axisym_thinfilm_dripping_faucet(s) 
 /// at local coordinate s
 inline double interpolated_h_axisym_thinfilm_dripping_faucet(const Vector<double> &s) const
  {
   //Find number of nodes
   const unsigned n_node = nnode();

   //Get the index at which the poisson unknown is stored
   const unsigned h_nodal_index = h_index_axisym_thinfilm_dripping_faucet();
   
   //Local shape function
   Shape psi(n_node);

   //Find values of shape function
   shape(s,psi);

   //Initialise value of h
   double interpolated_h = 0.0;

   //Loop over the local nodes and sum
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_h += this->nodal_value(l,h_nodal_index)*psi[l];
    }

   return(interpolated_h);
  }


 /// \short Return FE representation of function value u_axisym_thinfilm_dripping_faucet(s) 
 /// at local coordinate s
 inline double interpolated_u_axisym_thinfilm_dripping_faucet(const Vector<double> &s) const
  {
   //Find number of nodes
   const unsigned n_node = nnode();

   //Get the index at which the poisson unknown is stored
   const unsigned u_nodal_index = u_index_axisym_thinfilm_dripping_faucet();
   
   //Local shape function
   Shape psi(n_node);

   //Find values of shape function
   shape(s,psi);

   //Initialise value of u
   double interpolated_u = 0.0;

   //Loop over the local nodes and sum
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_u += this->nodal_value(l,u_nodal_index)*psi[l];
    }

   return(interpolated_u);
  }

 /// \short Return FE representation of function value omega_axisym_thinfilm_dripping_faucet(s) 
 /// at local coordinate s
 inline double interpolated_omega_axisym_thinfilm_dripping_faucet(const Vector<double> &s) const
  {
   //Find number of nodes
   const unsigned n_node = nnode();

   //Get the index at which the poisson unknown is stored
   const unsigned omega_nodal_index = omega_index_axisym_thinfilm_dripping_faucet();
   
   //Local shape function
   Shape psi(n_node);

   //Find values of shape function
   shape(s,psi);

   //Initialise value of omega
   double interpolated_omega = 0.0;

   //Loop over the local nodes and sum
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_omega += this->nodal_value(l,omega_nodal_index)*psi[l];
    }

   return(interpolated_omega);
  }

 /// dh/dt at local node n. 
 /// Uses suitably interpolated value for hanging nodes.
 double dh_dt_axisym_thinfilm_dripping_faucet(const unsigned &n) const
  {
   // Get the data's timestepper
   TimeStepper* time_stepper_pt = this->node_pt(n)->time_stepper_pt();

   //Initialise dhdt
   double dhdt=0.0;
   //Loop over the timesteps, if there is a non Steady timestepper
   if (!time_stepper_pt->is_steady())
    {
     //Get the index at which the velocity is stored
     const unsigned h_nodal_index = h_index_axisym_thinfilm_dripping_faucet();
     
     // Number of timsteps (past & present)
     const unsigned n_time = time_stepper_pt->ntstorage();

     //Add the contributions to the time derivative
     for(unsigned t=0;t<n_time;t++)
      {
       dhdt+=time_stepper_pt->weight(1,t)*nodal_value(t,n,h_nodal_index);
      }
    }
   
   return dhdt;
  }

 /// Return FE interpolated dh/dt at local coordinate s
 double interpolated_dhdt_axisym_thinfilm_dripping_faucet(const Vector<double> &s) const
  {
   // Get the data's timestepper
   TimeStepper* time_stepper_pt = this->node_pt(0)->time_stepper_pt();

   //Initialise dhdt
   double interpolated_dhdt=0.0;
   //Loop over the timesteps, if there is a non Steady timestepper
   if (!time_stepper_pt->is_steady())
    {
     // Determine number of nodes
     const unsigned n_node = nnode();

     // Allocate storage for local shape function and its derivatives
     // with respect to space
     Shape psif(n_node);
     DShape dpsifdx(n_node,1);

     // Find values of shape function (ignore jacobian)
     (void)this->dshape_eulerian(s,psif,dpsifdx);

     //Get the index at which the velocity is stored
     const unsigned h_nodal_index = h_index_axisym_thinfilm_dripping_faucet();
     
     // Number of timsteps (past & present)
     const unsigned n_time = time_stepper_pt->ntstorage();

     // Loop over the local nodes and sum
     for(unsigned l=0;l<n_node;l++)
      {
       //Add the contributions to the time derivative
       for(unsigned t=0;t<n_time;t++)
	      {
	        interpolated_dhdt+=time_stepper_pt->weight(1,t)*nodal_value(t,l,h_nodal_index)*psif[l];
      	}
      }
    }
   
   return interpolated_dhdt;
  }

 /// du/dt at local node n. 
 /// Uses suitably interpolated value for hanging nodes.
 double du_dt_axisym_thinfilm_dripping_faucet(const unsigned &n) const
  {
   // Get the data's timestepper
   TimeStepper* time_stepper_pt = this->node_pt(n)->time_stepper_pt();

   //Initialise dudt
   double dudt=0.0;
   //Loop over the timesteps, if there is a non Steady timestepper
   if (!time_stepper_pt->is_steady())
    {
     //Get the index at which the velocity is stored
     const unsigned u_nodal_index = u_index_axisym_thinfilm_dripping_faucet();
     
     // Number of timsteps (past & present)
     const unsigned n_time = time_stepper_pt->ntstorage();

     //Add the contributions to the time derivative
     for(unsigned t=0;t<n_time;t++)
      {
       dudt+=time_stepper_pt->weight(1,t)*nodal_value(t,n,u_nodal_index);
      }
    }
   
   return dudt;
  }

 /// Return FE interpolated du/dt at local coordinate s
 double interpolated_dudt_axisym_thinfilm_dripping_faucet(const Vector<double> &s) const
  {
   // Get the data's timestepper
   TimeStepper* time_stepper_pt = this->node_pt(0)->time_stepper_pt();

   //Initialise dudt
   double interpolated_dudt=0.0;
   //Loop over the timesteps, if there is a non Steady timestepper
   if (!time_stepper_pt->is_steady())
    {
     // Determine number of nodes
     const unsigned n_node = nnode();

     // Allocate storage for local shape function and its derivatives
     // with respect to space
     Shape psif(n_node);
     DShape dpsifdx(n_node,1);

     // Find values of shape function (ignore jacobian)
     (void)this->dshape_eulerian(s,psif,dpsifdx);

     //Get the index at which the velocity is stored
     const unsigned u_nodal_index = u_index_axisym_thinfilm_dripping_faucet();
     
     // Number of timsteps (past & present)
     const unsigned n_time = time_stepper_pt->ntstorage();

     // Loop over the local nodes and sum
     for(unsigned l=0;l<n_node;l++)
      {
       //Add the contributions to the time derivative
       for(unsigned t=0;t<n_time;t++)
	      {
	        interpolated_dudt+=time_stepper_pt->weight(1,t)*nodal_value(t,l,u_nodal_index)*psif[l];
      	}
      }
    }
   
   return interpolated_dudt;
  }

 /// Compute the volume of the element
 double compute_physical_size() const
 {
  // Initialise result
  double result = 0.0;

  // Set the value of n_intpt
  const unsigned n_intpt = integral_pt()->nweight();

  // Vector of local coordinates
  const unsigned n_dim = dim();
  Vector<double> s(n_dim);

  // Loop over the integration points
  for(unsigned ipt=0;ipt<n_intpt;ipt++)
   {
    // Assign the values of s 
    for(unsigned i=0;i<n_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}

    // Get the integral weight
    const double w = integral_pt()->weight(ipt);
     
    // Get Jacobian of mapping
    const double J = J_eulerian(s);
     
    // The integrand at the current integration point is r h
    result += interpolated_x(s,0)*interpolated_h_axisym_thinfilm_dripping_faucet(s)*w*J;
   }

  // Multiply by 2pi (integrating in azimuthal direction)
  return (2.0*MathematicalConstants::Pi*result);
 }


 /// \short Compute derivatives of elemental residual vector with respect
 /// to nodal coordinates. Overwrites default implementation in 
 /// FiniteElement base class.
 /// dresidual_dnodal_coordinates(l,i,j) = d res(l) / dX_{ij}
 /* virtual void get_dresidual_dnodal_coordinates(RankThreeTensor<double>& */
 /*                                               dresidual_dnodal_coordinates); */
 
 /// \short Self-test: Return 0 for OK
 unsigned self_test();


protected:

 /// Pointer to global Ohnesorg number
 double *Oh_pt;

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// local coord. s; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_axisym_thinfilm_dripping_faucet
   (const Vector<double> &s, 
    Shape &psi, 
    DShape &dpsidx, Shape &test, 
    DShape &dtestdx) const=0;
 

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_at_knot_axisym_thinfilm_dripping_faucet
   (const unsigned &ipt, 
    Shape &psi, 
    DShape &dpsidx,
    Shape &test, 
    DShape &dtestdx) 
   const=0;

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return Jacobian of mapping (J). Also compute
 /// derivatives of dpsidx, dtestdx and J w.r.t. nodal coordinates.
 virtual double dshape_and_dtest_eulerian_at_knot_axisym_thinfilm_dripping_faucet(
  const unsigned &ipt,
  Shape &psi,
  DShape &dpsidx,
  RankFourTensor<double> &d_dpsidx_dX,
  Shape &test, 
  DShape &dtestdx,
  RankFourTensor<double> &d_dtestdx_dX,
  DenseMatrix<double> &djacobian_dX) const=0;

 /// \short Compute element residual Vector only (if flag=and/or element 
 /// Jacobian matrix 
 virtual void fill_in_generic_residual_contribution_axisym_thinfilm_dripping_faucet(
  Vector<double> &residuals, DenseMatrix<double> &jacobian, 
  const unsigned& flag); 

 /// Pointer to source function:
 AxisymmetricThinFilmDrippingFaucetBodyForceFctPt Body_force_fct_pt;

};


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//======================================================================
/// AxisymmetricThinFilmDrippingFaucetElement elements are linear 
/// elements with isoparametric interpolation for the function.
//======================================================================
template <unsigned NNODE_1D>
 class AxisymmetricThinFilmDrippingFaucetElement : public virtual QElement<1,NNODE_1D>,
 public virtual AxisymmetricThinFilmDrippingFaucetEquations
{

private:

 /// \short Static int that holds the number of variables at 
 /// nodes: always the same
 static const unsigned Initial_Nvalue;
 
  public:


 ///\short  Constructor: Call constructors for QElement and 
 /// axisymmetric thin film DrippingFaucet equations
 AxisymmetricThinFilmDrippingFaucetElement() : QElement<1,NNODE_1D>(), 
   AxisymmetricThinFilmDrippingFaucetEquations()
  {}
 
 /// Broken copy constructor
 AxisymmetricThinFilmDrippingFaucetElement
   (const AxisymmetricThinFilmDrippingFaucetElement<NNODE_1D>& dummy) 
  { 
   BrokenCopy::broken_copy("AxisymmetricThinFilmDrippingFaucetElement");
  } 
 
 /// Broken assignment operator
 void operator=(const AxisymmetricThinFilmDrippingFaucetElement<NNODE_1D>&) 
  {
   BrokenCopy::broken_assign("AxisymmetricThinFilmDrippingFaucetElement");
  }

 /// \short  Required  # of `values' (pinned or dofs) 
 /// at node n
 inline unsigned required_nvalue(const unsigned &n) const 
  {return Initial_Nvalue;}

 /// \short Output function:  
 ///  x,y,u   or    x,y,z,u
 void output(std::ostream &outfile)
  {AxisymmetricThinFilmDrippingFaucetEquations::output(outfile);}


 ///  \short Output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(std::ostream &outfile, const unsigned &n_plot)
  {AxisymmetricThinFilmDrippingFaucetEquations::output(outfile,n_plot);}


 /// \short C-style output function:  
 ///  x,y,u   or    x,y,z,u
 void output(FILE* file_pt)
  {AxisymmetricThinFilmDrippingFaucetEquations::output(file_pt);}


 ///  \short C-style output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot)
  {AxisymmetricThinFilmDrippingFaucetEquations::output(file_pt,n_plot);}

protected:

/// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.
 inline double dshape_and_dtest_eulerian_axisym_thinfilm_dripping_faucet(
  const Vector<double> &s, Shape &psi, DShape &dpsidx, 
  Shape &test, DShape &dtestdx) const;


 /// \short Shape, test functions & derivs. w.r.t. to global coords. at
 /// integration point ipt. Return Jacobian.
 inline double dshape_and_dtest_eulerian_at_knot_axisym_thinfilm_dripping_faucet
   (const unsigned& ipt,
    Shape &psi, 
    DShape &dpsidx, 
    Shape &test,
    DShape &dtestdx) 
  const;

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return Jacobian of mapping (J). Also compute
 /// derivatives of dpsidx, dtestdx and J w.r.t. nodal coordinates.
 inline double dshape_and_dtest_eulerian_at_knot_axisym_thinfilm_dripping_faucet(
  const unsigned &ipt,
  Shape &psi,
  DShape &dpsidx,
  RankFourTensor<double> &d_dpsidx_dX,
  Shape &test, 
  DShape &dtestdx,
  RankFourTensor<double> &d_dtestdx_dX,
  DenseMatrix<double> &djacobian_dX) const;

};


//Inline functions:


//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
 double AxisymmetricThinFilmDrippingFaucetElement<NNODE_1D>::dshape_and_dtest_eulerian_axisym_thinfilm_dripping_faucet(
  const Vector<double> &s,
  Shape &psi, 
  DShape &dpsidx,
  Shape &test, 
  DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 const double J = this->dshape_eulerian(s,psi,dpsidx);

 //Set the test functions equal to the shape functions
 test = psi;
 dtestdx= dpsidx;
 
 //Return the jacobian
 return J;
}

//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
double AxisymmetricThinFilmDrippingFaucetElement<NNODE_1D>::
 dshape_and_dtest_eulerian_at_knot_axisym_thinfilm_dripping_faucet(
  const unsigned &ipt,
  Shape &psi, 
  DShape &dpsidx,
  Shape &test, 
  DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 const double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

 //Set the pointers of the test functions
 test = psi;
 dtestdx = dpsidx;

 //Return the jacobian
 return J;
}

//======================================================================
/// Define the shape functions (psi) and test functions (test) and
/// their derivatives w.r.t. global coordinates (dpsidx and dtestdx)
/// and return Jacobian of mapping (J). Additionally compute the
/// derivatives of dpsidx, dtestdx and J w.r.t. nodal coordinates.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
 double AxisymmetricThinFilmDrippingFaucetElement<NNODE_1D>::
 dshape_and_dtest_eulerian_at_knot_axisym_thinfilm_dripping_faucet(
  const unsigned &ipt,
  Shape &psi,
  DShape &dpsidx,
  RankFourTensor<double> &d_dpsidx_dX,
  Shape &test, 
  DShape &dtestdx,
  RankFourTensor<double> &d_dtestdx_dX,
  DenseMatrix<double> &djacobian_dX) const
 {
  // Call the geometrical shape functions and derivatives  
  const double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx,
                                                 djacobian_dX,d_dpsidx_dX);
  
  // Set the pointers of the test functions
  test = psi;
  dtestdx = dpsidx;
  d_dtestdx_dX = d_dpsidx_dX;
  
  //Return the jacobian
  return J;
}



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the 1D AxisymmetricThinFilmElement elements: Point elements
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<AxisymmetricThinFilmDrippingFaucetElement<NNODE_1D> >: 
 public virtual PointElement
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : PointElement() {}

};


}

#endif
